# 计算机网络

## 概述

计算机网络存在的意义：使得不同计算机之间可以进行通信。

#### Internet架构

全球最大的互联网，可以等同互联网，这是网络中的网络，通过光纤电缆、交换机、路由器和网络协议组成。

![](internet_infra.png)

![](internet_cons.jpg)

![](network_in_network.jpg)

#### 性能指标

+ 速率

+ 带宽

+ 时延：处理时延 排队时延 传输时延 传播时延

+ 往返时间rtt

+ 吞吐量

#### 输入url到返回的过程

dhcp udp 获取本机ip地址

arp 获取网关mac地址

http tcp三次握手（ syn; syn ack; ack） ip arp（外网则走网关mac地址）;以太网；物理网卡

交换机 nat协议 路由器（ispf bgp边际网关）

收到消息

tcp四次挥手（服务端fin ack fin ack 两倍来回）





## 应用层

网络应用是计算机网络存在的理由


#### HTTP超文本传输协议

80号端口，基于tcp

+ 持续连接

+ 非持续连接

##### http请求报文

##### http响应报文

##### 方法字段

+ GET

+ POST

+ HEAD

+ PUT

+ DELETE

##### 状态码

+ 1xx 

+ 2xx

+ 3xx

+ 4xx

+ 5xx

##### http代理服务器

##### 浏览器缓存

+ 强制缓存

+ 协商缓存


#### HTTPS


#### DNS域名系统

53号端口，在区域传输的时候使用TCP协议，其他时候使用UDP协议

##### 分级

+ 根dns服务器

+ 顶级域服务器

+ 权威dns服务器

+ 本地dns服务器

##### 查询

+ 递归

+ 迭代

##### dns缓存



## TCP协议

### TCP格式

TCP一共20个字节，五行，每行八个字节

源端口号 目标端口号
序列号
应答号
6位（syn ack fin rst push urg） 窗口大小
校验和 紧急指针

### 三次握手

客户端：随机序列号，syn

服务端：接收，随机序列号，应答号（syn算1），syn，ack，初始化窗口大小

客户端：接收

### 四次挥手

主动方：fin

被动方：接收，应答号（fin算1），ack

主动方：接收，等待被动方fin

被动方：fin

主动方：ack，等待2msl，关闭

被动方：收到fin，关闭

### 可靠传输

+ 发送方发送序列号，接收方发送应答号，这是可靠传输的核心
+ 发送方保存最小的已经发送但是未被确认的序列号，和下一个要发送的序列号
+ 不采用回退n步，或者选择重传，只发送最小未被确认序列号

### 重传机制

+ 单纯的ack包不会重传，携带了数据，syn、fin的ack包会重传
+ 重传时机：
  - 超时重传
  - 快速重传（收到冗余的相同3个序列号的ack，也就是第4个）

### 流量控制

+ 通过 最小的已经发送但是未被确认的序列号 和 对方上次发送的窗口大小，确定可以发送的窗口大小

### 拥塞控制

+ 慢启动
+ 拥塞避免
+ 拥塞发生
+ 快速恢复

### 11状态机

closed listening syn_send syn_received establish fin_wait1 fin_wait2 time_wait closing close_wait last_ack

### 保活机制

主动发送探测包的一方，序列号是上一次成功数据交互时的序列号减1

### 套接字编程底层

// server

int main() {

    int server_fd, client_fd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_len = sizeof(client_addr);
    char buffer[BUFFER_SIZE];
    
    // 1. 创建socket - 内核分配通信端点
    // 底层: 创建socket结构体、inode、文件描述符
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }
    
    // 配置服务器地址
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;           // IPv4地址族
    server_addr.sin_addr.s_addr = INADDR_ANY;   // 监听所有网络接口
    server_addr.sin_port = htons(PORT);         // 端口号(主机字节序转网络字节序)
    
    // 2. bind - 将socket与地址绑定
    // 底层: 将socket与IP:PORT绑定，更新路由表
    // 内核: 检查端口是否可用，设置sock->sk->sport和saddr
    if (bind(server_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        perror("bind failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }
    
    // 3. listen - 开始监听连接请求
    // 底层: 创建接受队列(未连接队列SYN_RCVD + 已连接队列ESTABLISHED)
    // 内核: 设置sock->state = TCP_LISTEN，创建backlog队列
    if (listen(server_fd, 5) == -1) {  // backlog=5，定义已完成队列长度
        perror("listen failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }
    
    printf("Server listening on port %d...\n", PORT);
    
    // 4. accept - 接受客户端连接(阻塞调用)
    // 底层: 从已连接队列取出一个连接，创建新socket
    // 内核: 如队列为空则进程睡眠，否则创建新sock并返回
    if ((client_fd = accept(server_fd, (struct sockaddr*)&client_addr, &client_len)) == -1) {
        perror("accept failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }
    
    printf("Client connected from %s:%d\n", 
           inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));
    
    // 5. 读取客户端数据
    // 底层: 从socket接收缓冲区拷贝数据到用户空间
    ssize_t bytes_read = read(client_fd, buffer, BUFFER_SIZE - 1);
    if (bytes_read > 0) {
        buffer[bytes_read] = '\0';
        printf("Received from client: %s\n", buffer);
        
        // 6. 发送响应数据
        // 底层: 数据拷贝到内核发送缓冲区，触发TCP传输
        char* response = "Hello from server!";
        write(client_fd, response, strlen(response));
    }
    
    // 7. 关闭连接(四次挥手)
    close(client_fd);
    close(server_fd);
    return 0;
}

// client

int main() {

    int sockfd;
    struct sockaddr_in serv_addr;
    char buffer[BUFFER_SIZE];
    
    // 1. 创建socket - 与服务端相同
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }
    
    // 配置服务器地址
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(PORT);
    
    // 将IP地址字符串转换为二进制格式
    if (inet_pton(AF_INET, SERVER_IP, &serv_addr.sin_addr) <= 0) {
        perror("invalid address");
        close(sockfd);
        exit(EXIT_FAILURE);
    }
    
    // 2. connect - 发起三次握手
    // 底层: 发送SYN包，等待SYN-ACK，回复ACK
    // 内核: 构建TCP头，设置序列号，启动重传定时器
    if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {
        perror("connect failed");
        close(sockfd);
        exit(EXIT_FAILURE);
    }
    
    printf("Connected to server %s:%d\n", SERVER_IP, PORT);
    
    // 3. 发送数据到服务器
    char* message = "Hello from client!";
    write(sockfd, message, strlen(message));
    
    // 4. 接收服务器响应
    ssize_t bytes_read = read(sockfd, buffer, BUFFER_SIZE - 1);
    if (bytes_read > 0) {
        buffer[bytes_read] = '\0';
        printf("Received from server: %s\n", buffer);
    }

    // 5. 关闭连接(四次挥手)
    close(sockfd);
    return 0;
}





## 传输层

#### 多路复用

#### UDP用户数据报协议

#### TCP传输控制协议

##### 可靠传输

+ 借助ack和seq两个字段确定，对于连接的双方，都维护着最近已确认的序列号

+ 从上层应用程序接收数据、超时、收到ack触发传送报文段

+ tcp保存已发送但未被接收的最小序列号和下一个要发送字节的序列号

+ 不采取回退n步或选择重传，tcp采取发送发送已发送但未被接收的最小序列号

##### 连接管理

+ 三次握手

+ 四次挥手

##### 超时重传

+ 超时

+ 快速重传：收到三个冗余ACK，意味着总共收到四个

##### 流量控制

+ 发送方维护winsize，这个由接收方发送表示自己接收方窗口大小

##### 拥塞控制

+ 慢启动

+ 拥塞避免

+ 快恢复

tahoe reno

##### 保活机制

+ 进程崩溃

+ 主机崩溃



## 网络层

MTU：ip首部加数据段的最大长度

### IP协议

### IP地址

+ 子网

+ 子网聚合

+ 最长前缀匹配

### 路由算法

#### 分类

+ 链路状态（LS）路由算法，基于dijkstra算法

+ 距离向量（DV）路由算法，基于bellman-ford算法

#### 自治系统（AS）

整个互联网路由信息过大，分为as

网关路由器：位于AS“边缘”，通过链路连接其他AS的网关路由器

#### RIP

+ 内部路由算法，基于dv（16跳表示无穷大）

#### OSPF

+ 内部路由算法，基于ls

#### BGP

自治系统之间路由算法

### icmp

### NAT

### dhcp

+ 主机广播 “DHCP discover”(发现报文) 0，0，0，0 255，255，255，255

+ DHCP服务器利用 “DHCP offer” (提供报文) 进行响应 附上分配的ip地址

+ 主机请求IP地址: “DHCP request” (请求报文) 

+ DHCP服务器分配IP地址: “DHCP ack” (确认报文) 包括分配给客户的IP地址、子网掩码、默认网关、DNS服务器地址


### arp

+ 同一局域网，查询目的mac

+ 不同局域网，查询网关mac




## 数据链路层

#### 网卡

#### 载波侦听多路访问协议

#### 局域网

##### MAC地址

##### 以太网协议

##### 以太网交换机

+ 存储-转发以太网帧

+ 检验到达帧的目的MAC地址，选择性(selectively) 向一个或多个输出链路转发帧

+ 利用CSMA/CD访问链路，发送帧

+ 主机感知不到交换机的存在

+ 即插即用 自学习
