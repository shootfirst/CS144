# CS144 斯坦福2021秋季计算机网络实验

## lab0

实验零有两小部分。分别是实现和手动获取网页相同功能的函数和实现内存字节流读取可靠服务

+ 手动获取网页

补充get_URL函数，代码量10几行

此部分关键点一我觉得是通过套接字和采用http协议的服务器沟通时，每行命令结束应该以\r\n结束，最后键入所有命令后同样要写入\r\n，如

GET /hello HTTP/1.1
Host: http://cs144.Keithw.org
Connection: close
你在写程序时应该这样"GET " + path + " " + "HTTP/1.1\r\nHost: " + host + "\r\nConnection: close\r\n\r\n"。

其次是调用shutdown函数时注意传入的参数，第一次我传入SHUT_RDWT,导致报错：read: Connection reset by peer

+ 内存可靠字节流

实现byte_stream.hh里面的ByteStream类相关函数，为方便代码编写可加入相关字段。关键在于缓冲区数据结构选取，我选的是list。

坑点：我开始实现时是read完结束时，给have_read变量一次性加上读取长度，可是测试不给我通过，我后来改成每pop一个have_read加1，给通过了。奇怪。



## lab1

实验一是实现一字节流重组器，将失序的字节流小块按顺序组装。
### 关键点

+ 重叠

字节流小块是有重叠的，甚至会包含，开始我以为像教材上一样，只会失序，而不会重叠（怪自己没好好看指导书），这是最关键的地方，也是最难解决的地方，解决好重叠这个关键点，实验思路基本理清

+ 数据结构

第二个是数据结构的选取，我开始选择的是链表，使用插入排序使得index有序，可是后来发现使用map可以使查找时间复杂度降到logn（对cpp不熟悉），果断使用map

### 编码思路

我没有添加辅助方法，所有处理都是实现在push_substring中，特别强大（甚至为实验三省写不少代码）。思路如下：首先对加入的data字符串进行切割，在map中找出和data重叠部分，进行切割，用start和len存储，最后调用sunstr。之后看是否能够写入_output能则写入，之后在map中弹出最小index直至不能加入，最后是后处理。具体步骤如下：
+ start：data子串的开始index
+ len：子串长度

+ 流程：
    + 对传入的data，在map中找上界up
      + 找到，判断是否交叉，交叉则判断是否被包围，包围则结束，否则修改start为up->first+up->second.size()-index;
      + 没有找到，判断index是否<=hope_to_rec,是则进行相应剪切和丢弃；
      
    + 在map中找下届down
      + 找到，判断是否交叉，交叉则判断是否包围，包围则删除down，继续2，否则修改len为down->first-start;否则直接插入，结束；
      + 没有找到，判断start是否越界，越界则丢弃，结束，否则插入map，结束；
      
    + 进行判断是否能写入_output，能则写入，判断是否全部写入，没有则将剩余插入map
    
    + 若成功写入且缓冲区未溢出，则在map中拿出第一个尝试写入，能则重复
  
    + 求eof_idx，若满足eof_idx<=hope_to_rec则结束写入



## lab2

实验二实现一个 TCPReceiver，用以接收传入的 TCP segment 并将其转换成用户可读的数据流。分为两个部分，索引转换和TCPReceiver 实现。

+ 索引转换

在TCP中，每个字节在数据流中的索引用一个32位的“序列号”（seqno）表示，这就增加了一些复杂性：

    + 开始和结束都算作序列中的一个位置：除了确保收到所有字节的数据外，TCP必须确保也能收到流的开始和结束。因此，在TCP中，SYN（数据流的开始）和FIN（数据流的结束）标志都被分配了序列号
    
    + 32位封装的序列号：在我们的StreamReassembler中，索引总是从0开始，并且有64位，在TCP中，传输的序列号是32位，如果数据流足够长的话，序列号就会循环
    
    + TCP序列号不从零开始：为了提高安全性和避免不同连接之间的混淆，TCP试图确保序列号不能被猜到，而且不太可能重复。因此，一个流的序列号不从零开始。流中的第一个序列号通常是一个随机的32位数字，称为初始序列号（ISN）
    
实现两个函数，wrap（绝对序列号转序列号）和unwrap（序列号转绝对序列号），unwrap注意余数相关性质，写得好45行代码解决。

+ TCPReceiver

实现三个方法：

    + segment received
        
        主要方法：对于 TCPReceiver 来说，除了错误状态以外，它一共有3种状态，分别是：

            + LISTEN：等待 SYN 包的到来。若在 SYN 包到来前就有其他数据到来，则必须丢弃
            + SYN_RECV：获取到了 SYN 包，此时可以正常的接收数据包
            + FIN_RECV：input_end，此时务必终止 ByteStream 数据流的输入
            
        状态设置：
            
            + 当 isn 还没设置时，肯定是 LISTEN 状态
            + 当 ByteStream.input_ended()，则肯定是 FIN_RECV 状态
            + 其他情况下，是 SYN_RECV 状态
        
        ackno 的计算必须考虑到 SYN 和 FIN 标志，因为这两个标志各占一个 seqno。故在返回 ackno 时，务必判断当前 接收者处于什么状态，然后依据当前状态来判断是否需要对当前的计算结果加1或加2。而这条准则对 push_substring 时同样适用。
        
        

    + ackno
    
        返回一个可选的<WrappingInt32>，包含接收方尚未知道的第一个字节的序列号。这就是窗口的左边缘：接收方感兴趣的第一个字节。如果ISN还没有被设置，返回一个空的可选值
        
    + window size
        
        求窗口大小
  
    










   


